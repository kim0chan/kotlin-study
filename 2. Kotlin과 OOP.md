## 🟣 클래스 <sub>Class</sub>
### 클래스 선언 및 인스턴스화
### 주 생성자와 보조 생성자
### 속성 (Properties)
### 메소드 (Methods)
### 중첩 클래스와 내부 클래스
### Enum Class
Enum은 'Enumeration'의 줄임말로, 서로 관련 있는 상수들의 집합을 정의할 때 사용한다.  
월, 화, 수, 목, 금, 토, 일 처럼 딱 정해져 있는 값들을 다룰 때 유용하다.
##### 기본 사용법
가장 기본적인 `enum class` 선언 방식이다.
```kotlin
enum class Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```
##### 프로퍼티와 메소드 정의하기
상수와 다른 점은, 단순히 값만 나열하는 게 아니라, 프로퍼티나 메소드도 가질 수 있다는 것이다.
```kotlin
// 프로퍼티를 갖는 enum class
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}

// 메소드를 갖는 enum class
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },
    TALKING {
        override fun signal() = WAITING
    }; // <--- 메소드를 정의할 땐 마지막에 세미콜론(;)을 찍어야 한다.

    abstract fun signal(): ProtocolState
}
```
심지어 각 상수가 다르게 동작하는 메소드를 구현하게 할 수도 있어서 유용하다.
##### 유용한 내장 기능들
`values()`나 `valueOf()` 같은 내장 함수도 있어서 모든 상수를 배열로 가져오거나, 이름으로 상수를 찾을 수도 있다.
- `Color.values()`: `[RED, GREEN, BLUE]` 배열을 반환한다.
- `Color.valueOf("RED")`: `Color.RED` 상수를 반환한다.
##### `when`과 함께 사용하기
특히 `when`이랑 같이 쓰면 코드가 엄청 깔끔해진다.  
컴파일러가 모든 경우를 다 체크했는지 알려주기도 하니까 실수할 일도 줄어든다.
```kotlin
fun handleDay(day: Day) {
    when (day) {
        Day.MONDAY -> println("월요병...")
        Day.FRIDAY -> println("금요일!")
        else -> println("파이팅,,,")
    }
}
```
### Sealed Class
### Data Class
### Companion Object
### 확장 함수 <sub>Extension Functions</sub>
### 연산자 오버로딩

## 🟣 상속 <sub>Inheritance</sub>
### 클래스 상속
### `open` 키워드
### 오버라이딩
### 추상 클래스

## 🟣 인터페이스 <sub>Interface</sub>
### 인터페이스 정의 및 구현
### 추상 메소드와 기본 구현
### 프로퍼티 선언

## 🟣 가시성 지시자 <sub>Visibility Modifiers</sub>
### `public`
### `private`
### `protected`
### `internal`
### 모듈과 가시성

## 🟣 구조분해 선언 <sub>Destructuring Declaration</sub>
### 정의 및 사용법
### Data Class와 함께 사용
### Map과 함께 사용

## 🟣 타입 별칭 <sub>Type Aliases</sub>
### 정의 및 사용법
### 활용 사례  