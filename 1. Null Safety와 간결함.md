## 🟣 Null Safety와 간결함
### Safe Call (`?.`)
- Kotlin은 NPE를 방지하기 위해 Nullable 타입을 도입했다.
- Safe Call(`?.`)은 Nullable 타입의 객체가 `null`이 아닌 경우에만 해당 객체의 멤버(메서드나 프로퍼티)에 접근하도록 해주는 연산자이다.
- 만약 객체가 `null`이면 전체 표현식은 `null`을 반환한다.
```kotlin
fun main() {  
    val name1: String? = "Kotlin"  
    val length1: Int? = name1?.length  
  
    val name2: String? = null  
    val length2: Int? = name2?.length  
  
    println("Length of name1 = $length1")  
    println("Length of name2 = $length2")  
}
```
```
Length of name1 = 6
Length of name2 = null
```
### Elvis Operator (`?:`)
- Nullable 표현식이 `null`이 아닌 경우 그 값을 사용하고, null일 경우 미리 정의된 기본 값을 사용하도록 하는 연산자이다.
- `if (value != null) value else defaultValue`같은 패턴을 간결하게 표현할 수 있다.
```kotlin
val nullText: String? = null
val textLength = nullText?.length ?: 0

// 예외를 던질 수도 있다.
val textLength = nullText?.length ?: throw IllegalArgumentException("...")
```
### Non-null Assertion (`!!`)
- `!!` 연산자는 Nullable 타입의 값을 Non-Nullable 타입으로 강제 변환한다.
    - Kotlin의 Null Safety 기능을 우회하는 것이기 때문에 사용에 신중해야 한다.
- 이 값이 `null`이 아님을 확신한다는 것을 컴파일러에게 알리는 것인데, 만약 `null`이면 NPE가 발생한다.
```kotlin
fun main() {  
    val someName: String? = null  
  
    try {  
        val assertedName: String = someName!!  
        println("이 라인은 실행되지 않는다.")  
    } catch (e: NullPointerException) {  
        println("NPE 발생!: ${e.message}")  
    }  
}
```
> 대부분의 경우 Safe Call(`?.`)이나 Elvis Operator(`?:`) 또는 `if (value != null)`같은 명시적 Null Check를 통해 NPE를 안전하게 처리하는 것이 좋다.

## 🟣 단일 표현식 함수 <sub>Single-Expression Functions</sub>
- 함수의 본문이 단일 표현식으로 구성될 때, 중괄호 `{}`와 `return` 키워드를 생략하고 `=` 기호를 사용하여 함수를 정의할 수 있다.
- 이 경우 해당 표현식의 결과가 함수의 반환 값이 된다.
```kotlinㅋ
import kotlin.math.max  
  
fun relu(x: Double): Double = max(0.0, x)
fun relu2(x: Double) = max(0.0, x)    // 반환 타입 추론
```

## 🟣 구조적 동등성 <sub>Structural Equality</sub>
- **Java와 비교**
    - 구조적 동등성이란 쉽게 말하면 **내용물이 똑같은지** 보는 것이다.
    - `==`: 두 객체의 내용물이 같은지 비교한다. (구조적 동등성)
        - 내부적으로 `equals()`를 안전하게 호출해준다.
    - `===`: 두 변수가 메모리에서 똑같은 하나의 객체를 가리키고 있는지 확인한다. (참조적 동등성)
- **JavaScript와 비교**

| 구분    | Kotlin              | JavaScript             |  
| ----- | ------------------- | ---------------------- |  
| `==`  | 구조적 동등성 (내용 비교)     | 느슨한 동등성 (타입 변환 후 값 비교) |  
| `===` | 참조적 동등성 (메모리 주소 비교) | 엄격한 동등성 (타입과 값 모두 비교)  |  

## 🟣 제어 흐름 <sub>Control Flow</sub>
### If 표현식
- 다른 언어의 `if`와 큰 차이 없다.
```kotlin
val a = 10
val b = 20
var max = a

if (b > a) {
	max = b
}

println("max value: $max")
```
- `else`나 `else if` 사용도 큰 차이 없다.
```kotlin
val temperature = 25

if (temperature > 30) {
	println("너무 덥다.")
} else if (temperature < 10) {
  println("너무 춥다.")
} else {
	println("쾌적하다.")
}
```
- 표현식(expression)으로 사용할 수 있다는 점은 좀 다르다.
```kotlin
val num1 = 15
val num2 = 20

val max = if (num1 > num2) {
	println("$num1이 더 큽니다.")
	num1  // 이 블록의 마지막 표현식이 반환 값
} else {
	println("$num2가 더 큽니다.")
	num2
}

println("결과: $max")
```

### For 루프
- Kotlin의 `for` 루프는 컬렉션, 범위, 배열 등 반복 가능한(iterable) 모든 것에 대해 반복한다.

- 범위(range) 반복
```kotlin
for (i in 1..5) {    // 1부터 5까지 (5 포함)
	print("$i ")    // 1 2 3 4 5 
}

for (i in 1 until 5) {    // 1부터 5까지 (5 미포함)
  print("$i ")    // 1 2 3 4 
}

for (i in 5 downTo 1) {    // 5부터 1까지 감소
  print("$i ")    // 5 4 3 2 1 
}

for (i in 1...10 step 2) {    // 1부터 10까지 2씩 증가
  print("$i ")    // 1 3 5 7 9 
}
```
- 컬렉션 반복
```kotlin
val fruits = listOf("apple", "banana", "cherry")

for (fruit in fruits) {
	println(fruit)
}
```
- 인덱스와 함께 반복
```kotlin
val names = arrayOf("Alice", "Bob", "Charlie")

for (i in names.indices) {
	println("이름[$i]: ${names[i]}")
}
```
- Map 반복
```kotlin
val ages = mapOf(
	"Alice" to 30,
	"Bob" to 25,
	"Charlie" to 35
)

for ((name, age) in ages) {
	println("$name 은(는) $age 살입니다.")
}
```