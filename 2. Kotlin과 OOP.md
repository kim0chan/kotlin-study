## 🟣 클래스 <sub>Class</sub>
### 클래스 선언 및 인스턴스화
### 주 생성자와 보조 생성자
### 속성 (Properties)
### 메소드 (Methods)
### 중첩 클래스와 내부 클래스
### Enum Class
Enum은 'Enumeration'의 줄임말로, 서로 관련 있는 상수들의 집합을 정의할 때 사용한다.  
월, 화, 수, 목, 금, 토, 일 처럼 딱 정해져 있는 값들을 다룰 때 유용하다.
##### 기본 사용법
가장 기본적인 `enum class` 선언 방식이다.
```kotlin
enum class Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```
##### 프로퍼티와 메소드 정의하기
상수와 다른 점은, 단순히 값만 나열하는 게 아니라, 프로퍼티나 메소드도 가질 수 있다는 것이다.
```kotlin
// 프로퍼티를 갖는 enum class
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}

// 메소드를 갖는 enum class
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },
    TALKING {
        override fun signal() = WAITING
    }; // <--- 메소드를 정의할 땐 마지막에 세미콜론(;)을 찍어야 한다.

    abstract fun signal(): ProtocolState
}
```
심지어 각 상수가 다르게 동작하는 메소드를 구현하게 할 수도 있어서 유용하다.
##### 유용한 내장 기능들
`values()`나 `valueOf()` 같은 내장 함수도 있어서 모든 상수를 배열로 가져오거나, 이름으로 상수를 찾을 수도 있다.
- `Color.values()`: `[RED, GREEN, BLUE]` 배열을 반환한다.
- `Color.valueOf("RED")`: `Color.RED` 상수를 반환한다.
##### `when`과 함께 사용하기
특히 `when`이랑 같이 쓰면 코드가 엄청 깔끔해진다.  
컴파일러가 모든 경우를 다 체크했는지 알려주기도 하니까 실수할 일도 줄어든다.
```kotlin
fun handleDay(day: Day) {
    when (day) {
        Day.MONDAY -> println("월요병...")
        Day.FRIDAY -> println("금요일!")
        else -> println("파이팅,,,")
    }
}
```
### Sealed Class
### Data Class
### Companion Object
### 확장 함수 <sub>Extension Functions</sub>
### 연산자 오버로딩

## 🟣 상속 <sub>Inheritance</sub>
### 클래스 상속
### `open` 키워드
### 오버라이딩
### 추상 클래스

## 🟣 인터페이스 <sub>Interface</sub>
### 인터페이스 정의 및 구현
### 추상 메소드와 기본 구현
### 프로퍼티 선언

## 🟣 가시성 지시자 <sub>Visibility Modifiers</sub>
### `public`
### `private`
### `protected`
### `internal`
### 모듈과 가시성

## 🟣 구조분해 선언 <sub>Destructuring Declaration</sub>
### 정의 및 사용법
### Data Class와 함께 사용
### Map과 함께 사용

## 🟣 타입 별칭 <sub>Type Aliases</sub>
- 기존 타입에 대한 **대체 이름**을 제공하는 기능이다.
- 코드 가독성을 높이고, 복잡하거나 긴 타입 이름을 더 간결하게 만들 때 유용하다.
    - (컴파일 시점에는 원래 타입으로 해석된다.)
### 문법
- `typealias` 키워드를 사용한다.
```kotlin
typealias newName = ExistingType
```
### 사용 예시
1. **함수 타입에 대한 별칭**
    - 콜백이나 리스너와 같이 복잡한 함수 타입을 여러 곳에서 사용할 때 유용하다.
```kotlin
// 원본 함수 타입: (String, Int) -> Unit
typealias SomeCallback = (message: String, code: Int) -> Unit

fun processData(data: String, callback: SomeCallback) {
	// 데이터 처리 로직
	if (data.isNotEmpty()) {
		callback("GOOD!", 200)
	} else {
		callback("NOOO!", 400)
	}
}

fun main() {
	val someHandler: SomeCallback = { msg, c ->
	  println("hi")
	}
}
```
2. **제네릭 타입에 대한 별칭**
    - 복잡한 제네릭 타입 선언을 간결하게 만들 수 있다.
```kotlin
typealias StringListMap = Map<String, List<String>>
```
3. **중첩 클래스 또는 긴 클래스 이름에 대한 별칭**
    - 클래스 이름이 길거나 중첩되어 있어 사용하기 번거로울 때 사용한다.
```kotlin
class OuterClass {
	class InnerClass {
		fun doSomething() {
			println("Greetings! I am an inner class.")
		}
	}
}

typealias Inner = OuterClass.InnerClass

fun main() {
	val instance = Inner()
	instance.doSomething()
}
```
4. **컬렉션 타입에 대한 별칭**
    - 컬렉션 타입의 목적을 명확히 할 때 사용한다.
```kotlin
typealias UserIds = Set<String>

fun processUserIds(ids: UserIds) {
	// ...
}
```
- ***주의사항***
    - **Type Safety 없음** - 컴파일 시점에 원래 타입으로 해석됨
    - **과도한 사용 지양** - 너무 많이 쓰면 코드 이해 및 유지보수 빡세짐
        - 함수 타입과 복잡한 제네릭에 잘 사용하면 좋을 것 같다.